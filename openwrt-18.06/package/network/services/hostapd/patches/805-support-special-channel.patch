Index: hostapd-2019-08-08-ca8c2bd2/src/ap/ap_list.c
===================================================================
--- hostapd-2019-08-08-ca8c2bd2.orig/src/ap/ap_list.c
+++ hostapd-2019-08-08-ca8c2bd2/src/ap/ap_list.c
@@ -174,6 +174,7 @@ void ap_list_process_beacon(struct hosta
 	struct ap_info *ap;
 	int new_ap = 0;
 	int set_beacon = 0;
+    int offset = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
 
 	if (iface->conf->ap_table_max_size < 1)
 		return;
@@ -233,7 +234,7 @@ void ap_list_process_beacon(struct hosta
 	    (ap->channel == 0 ||
 	     ap->channel == iface->conf->channel ||
 	     ap->channel == iface->conf->channel +
-	     iface->conf->secondary_channel * 4)) {
+	     iface->conf->secondary_channel * offset)) {
 		iface->olbc_ht = 1;
 		hostapd_ht_operation_update(iface);
 		wpa_printf(MSG_DEBUG, "OLBC HT AP detected: " MACSTR
Index: hostapd-2019-08-08-ca8c2bd2/src/ap/dfs.c
===================================================================
--- hostapd-2019-08-08-ca8c2bd2.orig/src/ap/dfs.c
+++ hostapd-2019-08-08-ca8c2bd2/src/ap/dfs.c
@@ -238,6 +238,9 @@ static void dfs_adjust_center_freq(struc
 				   u8 *oper_centr_freq_seg0_idx,
 				   u8 *oper_centr_freq_seg1_idx)
 {
+    int offset_ht = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 1 : 2;
+    int offset_vht = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 3 : 6;
+
 	if (!iface->conf->ieee80211ac && !iface->conf->ieee80211ax)
 		return;
 
@@ -249,14 +252,14 @@ static void dfs_adjust_center_freq(struc
 	switch (hostapd_get_oper_chwidth(iface->conf)) {
 	case CHANWIDTH_USE_HT:
 		if (secondary_channel == 1)
-			*oper_centr_freq_seg0_idx = chan->chan + 2;
+			*oper_centr_freq_seg0_idx = chan->chan + offset_ht;
 		else if (secondary_channel == -1)
-			*oper_centr_freq_seg0_idx = chan->chan - 2;
+			*oper_centr_freq_seg0_idx = chan->chan - offset_ht;
 		else
 			*oper_centr_freq_seg0_idx = chan->chan;
 		break;
 	case CHANWIDTH_80MHZ:
-		*oper_centr_freq_seg0_idx = chan->chan + 6;
+		*oper_centr_freq_seg0_idx = chan->chan + offset_vht;
 		break;
 	case CHANWIDTH_160MHZ:
 		*oper_centr_freq_seg0_idx = chan->chan + 14;
@@ -281,12 +284,14 @@ static int dfs_get_start_chan_idx(struct
 	int channel_no = iface->conf->channel;
 	int res = -1, i;
 	int chan_seg1 = -1;
+    int offset_ht = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
+    int offset_vht = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 3 : 6;
 
 	*seg1_start = -1;
 
 	/* HT40- */
 	if (iface->conf->ieee80211n && iface->conf->secondary_channel == -1)
-		channel_no -= 4;
+		channel_no -= offset_ht;
 
 	/* VHT/HE */
 	if (iface->conf->ieee80211ac || iface->conf->ieee80211ax) {
@@ -295,7 +300,7 @@ static int dfs_get_start_chan_idx(struct
 			break;
 		case CHANWIDTH_80MHZ:
 			channel_no = hostapd_get_oper_centr_freq_seg0_idx(
-				iface->conf) - 6;
+				iface->conf) - offset_vht;
 			break;
 		case CHANWIDTH_160MHZ:
 			channel_no = hostapd_get_oper_centr_freq_seg0_idx(
Index: hostapd-2019-08-08-ca8c2bd2/src/ap/hw_features.c
===================================================================
--- hostapd-2019-08-08-ca8c2bd2.orig/src/ap/hw_features.c
+++ hostapd-2019-08-08-ca8c2bd2/src/ap/hw_features.c
@@ -228,9 +228,10 @@ int hostapd_prepare_rates(struct hostapd
 static int ieee80211n_allowed_ht40_channel_pair(struct hostapd_iface *iface)
 {
 	int pri_chan, sec_chan;
+    int offset = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
 
 	pri_chan = iface->conf->channel;
-	sec_chan = pri_chan + iface->conf->secondary_channel * 4;
+	sec_chan = pri_chan + iface->conf->secondary_channel * offset;
 
 	return allowed_ht40_channel_pair(iface->current_mode, pri_chan,
 					 sec_chan);
@@ -240,11 +241,12 @@ static int ieee80211n_allowed_ht40_chann
 static void ieee80211n_switch_pri_sec(struct hostapd_iface *iface)
 {
     struct hostapd_data *hapd = container_of(&iface, struct hostapd_data, iface);
+    int offset = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
 	if (iface->conf->secondary_channel > 0) {
-		iface->conf->channel += 4;
+		iface->conf->channel += offset;
 		iface->conf->secondary_channel = -1;
 	} else {
-		iface->conf->channel -= 4;
+		iface->conf->channel -= offset;
 		iface->conf->secondary_channel = 1;
 	}
     hapd->iconf->channel = iface->conf->channel;
@@ -256,9 +258,10 @@ static int ieee80211n_check_40mhz_5g(str
 {
 	int pri_chan, sec_chan;
 	int res;
+    int offset = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
 
 	pri_chan = iface->conf->channel;
-	sec_chan = pri_chan + iface->conf->secondary_channel * 4;
+	sec_chan = pri_chan + iface->conf->secondary_channel * offset;
 
 	res = check_40mhz_5g(iface->current_mode, scan_res, pri_chan, sec_chan);
 
@@ -737,6 +740,7 @@ static int hostapd_is_usable_chans(struc
 {
 	int secondary_chan;
 	struct hostapd_channel_data *pri_chan;
+    int offset = (iface->conf->channel >= 175 && iface->conf->channel <= 181) ? 2 : 4;
 
 	pri_chan = hw_get_channel_chan(iface->current_mode,
 				       iface->conf->channel, NULL);
@@ -752,17 +756,17 @@ static int hostapd_is_usable_chans(struc
 	if (!iface->conf->ht40_plus_minus_allowed)
 		return hostapd_is_usable_chan(
 			iface, iface->conf->channel +
-			iface->conf->secondary_channel * 4, 0);
+			iface->conf->secondary_channel * offset, 0);
 
 	/* Both HT40+ and HT40- are set, pick a valid secondary channel */
-	secondary_chan = iface->conf->channel + 4;
+	secondary_chan = iface->conf->channel + offset;
 	if (hostapd_is_usable_chan(iface, secondary_chan, 0) &&
 	    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P)) {
 		iface->conf->secondary_channel = 1;
 		return 1;
 	}
 
-	secondary_chan = iface->conf->channel - 4;
+	secondary_chan = iface->conf->channel - offset;
 	if (hostapd_is_usable_chan(iface, secondary_chan, 0) &&
 	    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40M)) {
 		iface->conf->secondary_channel = -1;
Index: hostapd-2019-08-08-ca8c2bd2/src/common/hw_features_common.c
===================================================================
--- hostapd-2019-08-08-ca8c2bd2.orig/src/common/hw_features_common.c
+++ hostapd-2019-08-08-ca8c2bd2/src/common/hw_features_common.c
@@ -89,7 +89,7 @@ int allowed_ht40_channel_pair(struct hos
 {
 	int ok, first;
 	int allowed[] = { 36, 44, 52, 60, 100, 108, 116, 124, 132, 140,
-			  149, 157, 165, 184, 192 };
+			  149, 157, 165, 175, 179, 181, 184, 188, 192 , 196, 244, 252};
 	size_t k;
 	struct hostapd_channel_data *p_chan, *s_chan;
 	const int ht40_plus = pri_chan < sec_chan;
@@ -398,7 +398,12 @@ int hostapd_set_freq_params(struct hosta
 		if (center_segment1 ||
 		    (center_segment0 != 0 &&
 		     5000 + center_segment0 * 5 != data->center_freq1 &&
-		     2407 + center_segment0 * 5 != data->center_freq1))
+		     2407 + center_segment0 * 5 != data->center_freq1 &&
+             4000 + center_segment0 * 5 != data->center_freq1 && /*channel_idx = 188 or 192 or 196 or 200*/
+             3800 + center_segment0 * 5 != data->center_freq1 && /*channel_idx = 244 or 248 or 252 or 256*/
+             5010 + center_segment0 * 5 != data->center_freq1
+            )
+           )
 			return -1;
 		break;
 	case CHANWIDTH_80P80MHZ:
@@ -443,8 +448,17 @@ int hostapd_set_freq_params(struct hosta
 			if (center_segment0 == channel + 6 ||
 			    center_segment0 == channel + 2 ||
 			    center_segment0 == channel - 2 ||
-			    center_segment0 == channel - 6)
-				data->center_freq1 = 5000 + center_segment0 * 5;
+			    center_segment0 == channel - 6 ||
+                center_segment0 == 178) {
+                if (data->freq <= 5000)
+				    data->center_freq1 = 4000 + center_segment0 * 5;
+                else if (center_segment0 == 250)
+				    data->center_freq1 = 3800 + center_segment0 * 5;
+                else if (center_segment0 == 178)
+				    data->center_freq1 = 4110 + center_segment0 * 10;
+                else
+				    data->center_freq1 = 5000 + center_segment0 * 5;
+            }
 			else
 				return -1;
 		}
Index: hostapd-2019-08-08-ca8c2bd2/src/common/ieee802_11_common.c
===================================================================
--- hostapd-2019-08-08-ca8c2bd2.orig/src/common/ieee802_11_common.c
+++ hostapd-2019-08-08-ca8c2bd2/src/common/ieee802_11_common.c
@@ -762,7 +762,8 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 		return HOSTAPD_MODE_IEEE80211B;
 	}
 
-	if (freq >= 4900 && freq < 5000) {
+	/* 4 GHz, channels 188/192/196/200 */
+	if (freq >= 4940 && freq <= 5000) {
 		if ((freq - 4000) % 5)
 			return NUM_HOSTAPD_MODES;
 		*channel = (freq - 4000) / 5;
@@ -844,6 +845,17 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 		return HOSTAPD_MODE_IEEE80211A;
 	}
 
+	/* 5 GHz, channels 244/248/252/256 */
+	if (freq >= 5020 && freq <= 5080) {
+		if ((freq - 3800) % 5)
+			return NUM_HOSTAPD_MODES;
+
+		*channel = (freq - 3800) / 5;
+		*op_class = 0; /* TODO */
+
+		return HOSTAPD_MODE_IEEE80211A;
+	}
+
 	/* 5 GHz, channels 100..140 */
 	if (freq >= 5000 && freq <= 5700) {
 		if ((freq - 5000) % 5)
@@ -862,6 +874,16 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 
 		return HOSTAPD_MODE_IEEE80211A;
 	}
+
+    /* 5900/5920 */
+	if (freq >= 5860 && freq <= 5920) {
+		if ((freq - 4110) % 10)
+			return NUM_HOSTAPD_MODES;
+		*channel = (freq - 4110) / 10;
+		*op_class = 0;
+
+		return HOSTAPD_MODE_IEEE80211A;
+	}
 
 	if (freq >= 5000 && freq < 5900) {
 		if ((freq - 5000) % 5)
