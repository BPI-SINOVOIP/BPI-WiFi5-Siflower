Index: libiwinfo-2019-11-03-31dcef31/iwinfo_nl80211.c
===================================================================
--- libiwinfo-2019-11-03-31dcef31.orig/iwinfo_nl80211.c
+++ libiwinfo-2019-11-03-31dcef31/iwinfo_nl80211.c
@@ -2328,7 +2328,7 @@ static void nl80211_get_scanlist_ie(stru
 			break;
 
 		case 61: /* Secondary channel offset */
-			e->secondary_chan = ie[3] & 0x3; 
+			e->secondary_chan = ie[3] & 0x3;
 			break;
 
 		case 221: /* Vendor */
@@ -2931,6 +2931,7 @@ static int nl80211_get_modelist_cb(struc
 					m->hw |= IWINFO_80211_B;
 					m->hw |= IWINFO_80211_G;
 				}
+#ifdef HIDE_24G_SUPPORT_VHT
 				else if (bands[NL80211_BAND_ATTR_VHT_CAPA])
 				{
 					vht_caps = nla_get_u32(bands[NL80211_BAND_ATTR_VHT_CAPA]);
@@ -2952,6 +2953,36 @@ static int nl80211_get_modelist_cb(struc
 						}
 					}
 				}
+#else
+				if (bands[NL80211_BAND_ATTR_VHT_CAPA])
+				{
+					vht_caps = nla_get_u32(bands[NL80211_BAND_ATTR_VHT_CAPA]);
+
+					/* Treat any nonzero capability as 11ac */
+					if (vht_caps > 0)
+					{
+						if(nla_get_u32(freqs[NL80211_FREQUENCY_ATTR_FREQ]) < 2485){
+							m->hw |= IWINFO_80211_AC;
+							m->ht |= IWINFO_HTMODE_VHT20 | IWINFO_HTMODE_VHT40;
+						}
+						else{
+							m->hw |= IWINFO_80211_AC;
+							m->ht |= IWINFO_HTMODE_VHT20 | IWINFO_HTMODE_VHT40 | IWINFO_HTMODE_VHT80;
+
+							switch ((vht_caps >> 2) & 3)
+							{
+							case 2:
+								m->ht |= IWINFO_HTMODE_VHT80_80;
+								/* fall through */
+
+							case 1:
+								m->ht |= IWINFO_HTMODE_VHT160;
+							}
+						}
+
+					}
+				}
+#endif
 				else if (nla_get_u32(freqs[NL80211_FREQUENCY_ATTR_FREQ]) >= 56160)
 				{
 					m->hw |= IWINFO_80211_AD;
